# 最优样本选择系统 - 详细使用指南

## 1. 软件概述

最优样本选择系统是一款专为解决复杂样本选择优化问题而设计的桌面应用程序。它旨在帮助研究人员、数据分析师和工程师在满足特定覆盖标准的前提下，从较大的样本池中高效地识别出最具代表性或最优化的样本子集。本系统通过直观的图形用户界面（GUI）简化了操作流程，集成了两种核心优化算法（贪心算法和整数线性规划），并提供了便捷的结果管理功能。

## 2. 软件组成

系统主要由以下几个部分组成：

### 2.1 核心代码文件

- **`gui.py`**：图形用户界面（GUI）的主程序文件。负责创建窗口、布局控件、处理用户输入、调用算法模块以及展示计算结果。
- **`optimal_selection.py`**：包含核心样本选择算法的实现。定义了 `greedy_optimal_selection` 和 `ilp_optimal_selection` 两个关键函数。
- **`hook-sv_ttk.py`**：PyInstaller 打包所需的钩子文件，用于确保 `sv_ttk` 主题库能被正确包含在最终的可执行文件中。
- **`hook-pulp.py`**：PyInstaller 打包所需的钩子文件，用于确保 `pulp` 库及其依赖的 CBC 求解器能被正确包含。

### 2.2 主要目录结构

- **`results/`**：默认用于存储所有计算结果的目录。每次成功计算并保存后，会在此目录下生成一个 JSON 文件。
- **`dist/`**：使用 PyInstaller 打包后生成的可执行文件及其依赖项所在的目录（如果使用 `--onefile` 参数，则只有一个 `.exe` 文件）。
- **`build/`**：PyInstaller 打包过程中生成的临时文件目录。

## 3. 核心功能

### 3.1 最优样本选择算法

系统实现了两种算法来解决最优样本选择问题：

#### 3.1.1 贪心算法 (Greedy Algorithm)

**工作原理**：贪心算法是一种启发式方法。在每一步选择中，它都挑选当前看起来最优的 k 样本组，即能够覆盖最多“尚未被充分覆盖”的 j 样本组的 k 样本组。它不断重复这个过程，直到所有的 j 样本组都满足了 `coverage` 要求。

**优点**：
- **速度快**：计算复杂度相对较低，特别适用于 m 和 n 值非常大的情况。
- **实现简单**。

**缺点**：
- **不保证全局最优**：由于只关注局部最优选择，最终找到的 k 样本组数量可能不是理论上的最小值。

**适用场景**：
- 问题规模非常大，ILP 算法耗时过长时。
- 对解的最优性要求不高，允许接受近似最优解时。
- 快速获得一个可行解进行初步分析时。

#### 3.1.2 整数线性规划 (Integer Linear Programming, ILP) 算法

**工作原理**：ILP 算法将样本选择问题转化为一个标准的数学优化模型。它定义了一组决策变量（表示是否选择某个 k 样本组）和一个目标函数（最小化所选 k 样本组的数量），以及一系列线性约束条件（确保每个 j 样本组都被至少 `coverage` 个选定的 k 样本组所覆盖）。然后，利用外部的 ILP 求解器（如 CBC）来精确求解这个模型。

**优点**：
- **保证全局最优**：只要计算时间足够，ILP 算法能够找到理论上最优的解，即最小数量的 k 样本组。

**缺点**：
- **计算速度慢**：随着样本数量（特别是 n）的增加，可能的 k 样本组数量和约束数量会急剧增长，导致求解时间显著增加，甚至可能无法在合理时间内完成。
- **依赖外部求解器**：需要正确安装和配置 CBC 求解器（已通过 `pulp` 库集成）。

**适用场景**：
- 对解的最优性有严格要求时。
- 问题规模适中（n 值相对较小），计算时间可接受时。

### 3.2 用户界面功能

系统提供了现代化的图形用户界面，主要功能包括：

- **参数输入区**：用于设置核心算法参数（m, n, k, j, s, coverage）。
- **样本输入区**：可以选择手动输入样本名称（逗号分隔）或让系统从 1 到 m 的整数中随机选择 n 个样本。
- **算法选择区**：通过下拉菜单选择使用“贪心算法”或“整数线性规划”。
- **控制按钮区**：包括“运行计算”、“保存结果”、“清空输入/结果”等操作按钮。
- **结果显示区**：一个文本框，用于显示计算过程中的信息和最终选定的 k 样本组列表。
- **历史结果管理区**：一个列表框，显示 `results/` 目录下的所有结果文件，并提供查看、删除和刷新功能。

### 3.3 结果保存与管理

计算完成后，结果可以保存为 JSON 文件，存储在 `results/` 目录下。这有助于记录和比较不同参数设置下的运行结果。

**文件命名规范**：
文件名包含了该次计算的关键信息，格式如下：
`m<m_val>-n<n_val>-k<k_val>-j<j_val>-s<s_val>-cov<coverage_val>-run<run_idx>-res<num_k_groups>-<timestamp>.json`

- `<m_val>`, `<n_val>`, ... `<coverage_val>`：对应的参数值。
- `<run_idx>`：运行索引（用于区分相同参数的多次运行，暂未完全实现）。
- `<num_k_groups>`：找到的最优 k 样本组的数量。
- `<timestamp>`：保存结果时的时间戳（格式：YYYYMMDD_HHMMSS）。

**JSON 文件内容示例**：
```json
{
  "params": {
    "m": 100,
    "n": 20,
    "k": 10,
    "j": 5,
    "s": 3,
    "coverage": 1,
    "algorithm": "Greedy",
    "samples": [1, 5, 8, ..., 99] // n个样本列表
  },
  "run_index": 1,
  "selected_k_groups": [
    [1, 5, 8, 12, 15, 22, 30, 45, 50, 61],
    [...],
    // 其他选定的k样本组
  ],
  "num_selected_k_groups": 5 // 结果数量
}
```

## 4. 安装指南

### 4.1 从源代码运行

**前提条件**：
- 已安装 Python (推荐 3.8 或更高版本)。
- 已安装 pip 包管理器。

**步骤**：
1.  **克隆或下载代码**：
    ```bash
    git clone <repository_url> # 如果使用 Git
    cd <project_directory>
    ```
    或者直接下载 ZIP 压缩包并解压。
2.  **安装依赖库**：
    打开终端或命令提示符，导航到项目根目录，然后运行：
    ```bash
    pip install sv_ttk pulp
    ```
    *   `sv_ttk`：用于提供现代化的 Tkinter 主题。
    *   `pulp`：用于实现整数线性规划算法，并会自动安装 CBC 求解器（如果系统中没有）。
3.  **运行程序**：
    在项目根目录下运行：
    ```bash
    python gui.py
    ```
    系统图形界面将会启动。

### 4.2 使用预编译的可执行文件 (Windows)

如果提供了预编译的 `.exe` 文件（通常位于 `dist/` 目录下），用户可以直接在 Windows 系统上运行，无需手动安装 Python 或任何依赖库。

1.  **获取 `.exe` 文件**：从发布渠道下载 `gui.exe`（或类似名称的文件）。
2.  **运行**：双击该 `.exe` 文件即可启动应用程序。

**注意**：首次运行时，Windows Defender 或其他杀毒软件可能会进行安全扫描，这可能导致启动稍有延迟。

### 4.3 自行打包应用程序 (使用 PyInstaller)

如果您想自己将 Python 源代码打包成独立的可执行文件，可以按照以下步骤操作：

1.  **安装 PyInstaller**：
    ```bash
    pip install pyinstaller
    ```
2.  **执行打包命令**：
    在项目根目录下，打开终端或命令提示符，运行以下命令：
    ```bash
    pyinstaller --onefile --windowed --name OptimalSampleSelector --icon=app.ico --additional-hooks-dir=. gui.py
    ```
    **参数说明**：
    *   `--onefile`：将所有内容打包成一个单独的 `.exe` 文件。
    *   `--windowed`：运行时不显示命令行窗口（适用于 GUI 应用）。
    *   `--name OptimalSampleSelector`：指定生成的可执行文件的名称。
    *   `--icon=app.ico`：指定应用程序的图标文件（可选，需准备 `app.ico` 文件）。
    *   `--additional-hooks-dir=.`：指定包含 `hook-sv_ttk.py` 和 `hook-pulp.py` 的目录（当前目录 `.`）。这对于确保 `sv_ttk` 和 `pulp` (含 CBC) 被正确打包至关重要。
    *   `gui.py`：要打包的主程序文件。

3.  **查找可执行文件**：
    打包成功后，可在生成的 `dist/` 目录下找到 `OptimalSampleSelector.exe` 文件。

4.  **打包问题排查**：
    如果打包后的程序运行出错，特别是与 `sv_ttk` 或 `pulp`/CBC 相关的问题，请检查：
    *   钩子文件 (`hook-*.py`) 是否存在且位于 `--additional-hooks-dir` 指定的目录下。
    *   尝试不使用 `--onefile` 参数打包，检查 `dist/` 目录下是否包含了 `sv_ttk` 和 `pulp` 的相关文件及 CBC 求解器。
    *   查阅 PyInstaller 和相关库的文档获取更详细的打包指导。

## 5. 使用指南

### 5.1 参数详解与设置

在运行计算前，需要正确设置以下参数：

1.  **m (Total Samples)**：样本池的总大小。例如，如果有 100 个候选样本，则 m = 100。样本通常用从 1 到 m 的整数表示。
2.  **n (Selected Samples)**：实际参与计算的样本数量。系统会从 m 个总样本中选取 n 个样本（手动指定或随机选择）来进行后续的组划分和覆盖计算。n 必须小于或等于 m。
3.  **k (Group Size)**：最终要选择的样本组的大小。算法的目标是找到最少数量的、大小为 k 的样本组。
4.  **j (Subset Size)**：需要被覆盖的目标子集的大小。系统会考虑所有从 n 个样本中选出的、大小为 j 的子集。
5.  **s (Coverage Size)**：判断覆盖是否发生的标准。对于一个大小为 j 的子集，如果某个大小为 k 的组包含了该 j 子集中的至少 s 个样本，则认为这个 k 组覆盖了该 j 子集。
6.  **Coverage (Min Coverage Count)**：每个大小为 j 的子集需要被多少个不同的 k 组覆盖的最小次数。通常设置为 1，表示每个 j 子集至少被一个 k 组覆盖即可。

**参数约束条件**：
这些参数必须满足以下逻辑关系：
`s ≤ j ≤ k ≤ n ≤ m`

**设置建议**：
- 从小规模参数开始测试（例如 m=20, n=10, k=5, j=4, s=3, coverage=1），理解算法行为。
- 增大 n 会显著增加计算复杂度，特别是对于 ILP 算法。
- k 值越大，通常找到的 k 组数量会越少，但单个组包含的信息也越多。
- j 和 s 定义了覆盖的“粒度”。s 越接近 j，覆盖条件越严格。

### 5.2 选择参与计算的 n 个样本

在设定好参数 m 和 n 之后，需要确定具体是哪 n 个样本参与计算。系统提供两种方式：

1.  **手动输入 (Manual Input)**：
    -   在标有“Enter n samples (comma-separated)”的文本框中，输入 n 个样本的标识符，用英文逗号 `,` 分隔。
    -   样本标识符可以是数字或字符串（但内部算法目前主要处理数字）。
    -   确保输入的样本数量正好是 n 个。
    -   **注意**：如果 m 很大，手动输入可能不方便。
2.  **随机选择 (Random Selection)**：
    -   勾选“Randomly select n from m samples”复选框。
    -   系统将在运行时，自动从 1 到 m 的整数中随机、不重复地选择 n 个样本。
    -   这是处理大规模 m 的常用方式。

### 5.3 选择优化算法

根据问题的规模和对解的最优性要求，选择合适的算法：

1.  **贪心算法 (Greedy)**：
    -   **选择时机**：当 n 值较大，或者对计算时间有严格限制时。
    -   **特点**：速度快，结果是近似最优解。
2.  **整数线性规划 (ILP)**：
    -   **选择时机**：当需要确保找到理论最优解，且 n 值适中，计算时间可接受时。
    -   **特点**：保证全局最优，但速度较慢，计算复杂度随 n 指数级增长。

通过界面上的下拉菜单进行选择。

### 5.4 执行计算与保存结果

1.  **检查参数**：确保所有参数 (m, n, k, j, s, coverage) 已设置，并满足 `s ≤ j ≤ k ≤ n ≤ m`。
2.  **选择样本**：确定使用手动输入还是随机选择 n 个样本。
3.  **选择算法**：通过下拉菜单选择“Greedy”或“ILP”。
4.  **开始计算**：点击 **"Run Optimal Selection"** 按钮。
    -   计算过程中，状态信息（如“Running Greedy Algorithm...”、“Solving ILP...”）会显示在结果输出区域。
    -   ILP 算法可能需要较长时间，请耐心等待。
5.  **查看结果**：计算完成后，结果输出区域会显示找到的最优 k 样本组列表以及总数量。
6.  **保存结果**：如果对结果满意，点击 **"Save Results"** 按钮。
    -   系统会根据当前参数和时间戳生成一个 JSON 文件名，并将其保存在 `results/` 目录下。
    -   同时，右侧的历史结果列表会自动刷新，显示新保存的文件。

### 5.5 查看与管理历史结果

界面右侧提供了历史结果管理功能：

1.  **结果列表 (Saved Results)**：
    -   列表框中显示了 `results/` 目录下所有符合命名规范的 `.json` 文件。
    -   文件名本身就包含了该次运行的主要参数信息。
2.  **查看详情 (View Details)**：
    -   在列表中单击选中一个结果文件。
    -   该文件的详细内容（包括参数和选定的 k 组）将加载并显示在下方的“Result Details”文本区域中。
3.  **删除结果 (Delete Selected)**：
    -   在列表中选中一个或多个结果文件（按住 Ctrl 或 Shift 可多选）。
    -   点击 **"Delete Selected"** 按钮。
    -   系统会提示确认删除，确认后将从 `results/` 目录中移除所选文件，并刷新列表。
4.  **刷新列表 (Refresh List)**：
    -   如果手动在 `results/` 目录中添加或删除了文件，可以点击 **"Refresh List"** 按钮来更新界面上的列表显示。

## 6. 常见问题解决

### 6.1 打包相关问题 (PyInstaller)

#### 6.1.1 `sv_ttk` 主题加载失败

**症状**：打包后的 `.exe` 文件运行时，界面显示为原始的、未经美化的 Tkinter 样式，而不是 Sun Valley 主题。

**原因**：PyInstaller 未能自动发现并包含 `sv_ttk` 库所需的主题文件。

**解决方案**：
1.  **使用 `hook-sv_ttk.py` 文件（推荐）**：
    -   确保 `hook-sv_ttk.py` 文件与 `gui.py` 在同一目录或指定的钩子目录中。
    -   在 PyInstaller 命令中添加 `--additional-hooks-dir=.` （如果钩子在当前目录）或指定包含钩子文件的目录。
    ```bash
    pyinstaller ... --additional-hooks-dir=. gui.py
    ```
2.  **显式包含数据文件**：如果钩子无效，可以尝试手动指定 `sv_ttk` 的数据文件路径（需要找到 `sv_ttk` 安装位置下的 `sv.tcl` 等文件）。
    ```bash
    pyinstaller ... --add-data "path/to/sv_ttk/sv.tcl;sv_ttk" ... gui.py
    ```
    (路径需要根据实际情况修改)
3.  **检查代码中的回退机制**：确认 `gui.py` 中存在尝试导入 `sv_ttk` 失败时回退到标准 `ttk` 的逻辑，确保即使主题加载失败，程序也能基本运行。
    ```python
    try:
        import sv_ttk
        sv_ttk.set_theme("light") # or "dark"
    except ImportError:
        print("sv_ttk not found, using default ttk theme.")
        # Optional: Apply standard ttk styling if needed
    ```

#### 6.1.2 ILP 算法无法找到 CBC 求解器

**症状**：运行打包后的 `.exe` 文件，选择 ILP 算法并点击“Run”后，程序报错，提示找不到 CBC 求解器或类似信息。

**原因**：PyInstaller 未能将 `pulp` 库依赖的 CBC 求解器可执行文件正确打包进去，或者打包后的程序无法在运行时定位到求解器。

**解决方案**：
1.  **使用 `hook-pulp.py` 文件（推荐）**：
    -   确保 `hook-pulp.py` 文件存在且被 PyInstaller 使用（通过 `--additional-hooks-dir`）。此钩子通常会处理 `pulp` 及其默认求解器的打包。
    ```bash
    pyinstaller ... --additional-hooks-dir=. gui.py
    ```
2.  **显式收集 `pulp` 数据**：有时需要更明确地告诉 PyInstaller 收集 `pulp` 的所有相关文件。
    ```bash
    pyinstaller ... --collect-all pulp --additional-hooks-dir=. gui.py
    ```
3.  **检查 `optimal_selection.py` 中的求解器路径处理**：
    -   确认 `ilp_optimal_selection` 函数中存在针对打包环境 (`sys.frozen`) 的特殊处理逻辑，尝试在打包后的环境中动态定位 CBC 求解器路径。
    -   代码段示例（已存在于当前 `optimal_selection.py`）：
        ```python
        import sys
        import os
        is_frozen = getattr(sys, 'frozen', False)
        solver = None
        if is_frozen:
            # Try to find solver relative to executable
            base_path = os.path.dirname(sys.executable)
            # Adjust the relative path based on how pulp packages CBC
            solver_path = os.path.join(base_path, "pulp", "solverdir", "cbc", "win", "64", "cbc.exe") # Example path
            if os.path.exists(solver_path):
                solver = pulp.PULP_CBC_CMD(path=solver_path, msg=0)
            else:
                print(f"Warning: CBC solver not found at expected packaged location: {solver_path}")
                # Fallback to default search
                solver = pulp.PULP_CBC_CMD(msg=0)
        else:
            solver = pulp.PULP_CBC_CMD(msg=0)

        if solver:
            prob.solve(solver)
        else:
            raise RuntimeError("Could not configure CBC solver.")
        ```
    -   **重要**：`solver_path` 的具体相对路径可能需要根据 `pulp` 版本和 PyInstaller 打包结构进行调整和测试。
4.  **环境变量**：在某些情况下，可能需要设置 `PULP_CBC_CMD` 环境变量指向求解器路径，但这对于分发给用户的打包应用不太现实。

### 6.2 常见运行问题与排查

1.  **参数错误 (ValueError: Parameters must satisfy s <= j <= k <= n <= m)**
    -   **原因**：输入的参数不满足基本的逻辑约束。
    -   **解决**：仔细检查并修改 m, n, k, j, s 的值，确保它们按非递减顺序排列。
2.  **ILP 求解失败 (RuntimeError: ILP solving failed...)**
    -   **原因**：
        *   CBC 求解器未找到或配置错误（尤其是在打包应用中）。
        *   模型本身不可行（可能是参数设置导致无解）。
        *   求解器在计算过程中遇到内部错误。
    -   **解决**：
        *   如果是打包问题，参考 6.1.2 节。
        *   检查参数设置是否合理。尝试使用更简单的参数组合。
        *   确保 `pulp` 库和 CBC 求解器安装正确（如果从源码运行）。
3.  **ILP 算法运行时间过长**
    -   **原因**：n 值过大导致组合爆炸，计算量巨大。
    -   **解决**：
        *   减小 n 的值。
        *   改用贪心算法 (Greedy)。
        *   增加 `coverage` 参数有时可能（但不保证）帮助求解器更快找到解（因为它增加了约束）。
        *   在更强大的硬件上运行。
4.  **贪心算法结果不理想**
    -   **原因**：贪心算法不保证全局最优。
    -   **解决**：
        *   如果对最优性要求高，且问题规模允许，尝试使用 ILP 算法。
        *   接受贪心算法的近似解。
5.  **随机选择样本时结果不一致**
    -   **原因**：每次运行“随机选择”会产生不同的 n 个样本子集，导致结果不同。
    -   **解决**：这是预期行为。如果需要可复现的结果，应使用“手动输入”指定相同的 n 个样本。
6.  **界面卡顿或无响应**
    -   **原因**：计算量大时（特别是 ILP），主线程被阻塞。
    -   **解决**：耐心等待计算完成。未来的版本可以考虑将计算放到后台线程执行以保持界面响应。

## 7. 技术支持与反馈

如果您在使用过程中遇到本指南未涵盖的问题，或者有任何功能建议、改进意见，欢迎通过以下方式联系我们：

- **[在此处插入联系方式，例如邮箱地址、项目 Issue 页面链接等]**

请在反馈时尽量提供详细信息，包括：
- 您使用的操作系统。
- 是从源代码运行还是使用打包版本。
- 遇到问题时的具体参数设置。
- 详细的错误信息或问题描述。
- 如果可能，附上相关的截图。

---

*文档版本：1.1*
*最后更新日期：2024年7月26日*